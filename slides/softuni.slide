Програмиране с езика Go
20 Декември 2016
Tags: golang, softuni

Емил Станчев, Ивелин Славов, Диан Тодоров
Uber Bulgaria

stanchev@uber.com
ivelin@uber.com
dido@uber.com

* Какво е Go?

.image assets/gopherbw.png _ 200

Език с отворен код, който прави лесно създаването на опростен, надежден и ефикасен софтуер.

* Какво е Go?

- C на 21 век
- Изключително малък, само 25 запазени думи
- Автоматично управление на паметта
- Много изразителен модел на конкурентност
- Статична типизация, алтернатива на динамични скриптови езици
- Развита екосистема от инструменти(gofmt, godoc, ...)
- Без Makefiles
- Static linking
- Безумно бързи компилация и изпълнение
- Създаден за да скалира, Cross Platform

* Малко за Gopher

- Автор: Renee French
- Също талисман на Plan 9
.image assets/glenda.png _ 200

* Още от Renee French

.image assets/renee.png _ 300

* История и създатели

.image ./assets/RobKenRobert.png _ 300

- експеримент в Google, който стартира 2007г.
- Ken Thompson е един от авторите на оригиналната Unix ОС и B - езика, предшественик на C.
- Rob Pike е работил в Bell Labs върху Plan 9 (Unix ОС)
- Robert Griesemer е работил по Java Hotspot Virtual Machine
- Не им харесва C++ и дългото време за компилация на големи приложения
- Ако нещо влиза в езика, то и тримата трябва да са съгласни
- Rob Pike и Ken Thompson са създателите на UTF-8

* История във времето 

- 2007 - ражда се идеята
- 2008 - стартира разработката на компилатора
- 2009 - първи публичен релийз
- 2010 - обявен за език на годината
- 2011 - използва се в production среда от Google
- 2012 - излиза 1.0
- 2013 - излизат са 1.1 и 1.2
- 2014 - излизат са 1.3 и 1.4
- 2015 - излиза е 1.5
- 2016 - излизат са 1.6 и 1.7

* Какъв тип проекти са подходящи за Go?

- Мащабни проекти и дистрибутирани системи
- High-throughput, скалируеми network сървъри
- Command-line инструменти
- Инфраструктура (load balancers, cluster managers, docker)
- Автоматизация
- GUI - не особено
- Embedded софтуер, kernel development - не особено

* Go извън Google

Bitbucket
Booking.com
Dropbox
Facebook
GitHub
Google / YouTube
Heroku
Netflix
SoundCloud
SpaceX
Tumblr
Twitter
Uber
VMware
\...

* Open-source

- Docker - популярен инструмент за управление на леки виртуални машини (контейнери)
- Doozer - конситентна, high-availability база данни
- InfluxDB - база данни за времеви редове (timeseries)
- Vault - инструмент за управление на криптирани тайни (напр. пароли)
- Packer - инструмент за създаване на образи на виртуални машини (VM images)
- Syncthing - клиент/сървър за синхронизация на файлове

* Hello World


.play code/hello.go

Изпълним файл с размер от 1.5MB на машина със следните свойства:
- go version go1.7.4 darwin/amd64
- OS X El Capitan
- 3.1 GHz Intel Core i7

* Fizz buzz

.play code/fizzbuzz.go

* Пакети

  package main

- Пакетите са основна структурна единица на едно Go приложение
- Комбинация между библиотека, namespace и модул
- Всеки файл е част от точно един пакет. Един пакет може да включва много файлове
- По конвенция всяка директория съдържа един пакет
- Всяко изпълнимо приложение има точно един пакет `main` и една функция `main`
- Програмата приключва, когато `main` функцията приключи
- Няма циклични зависимости

* Използване на пакети

  import "main"

- Няколко пакета могат да бъдат импортирани с един `import`:

  import (
    "fmt"
    "encoding/json"
    "github.com/satori/go.uuid"
  )

- Достъпни са публичните (с главна буква) имена от пакета:

  fmt.Println("Hello!")

- Неизползването на импортирани пакети води до компилационна грешка

- При импортиране, може да бъде зададено алтернативно име:

  import "log"                          // Standard package
  import googlelog "google/base/go/log" // Google-specific package

* Променливи

- `var` създава нова променлива от даден тип, свързва я с име, и присвоява начална стойност

  var s string = "hello"
  var a, b, c = true, 3.14, "hello"
  var f, err = os.Open("filename")

- Кратка декларация на променливи (типът се извежда автоматично от компилатора)

  s := "hello"

- Обикновено се използва кратката декларация, освен ако не е нужно изрично указване на типа

* Присвояване на променливи

- Променя стойността на съществуваща променлива

.play code/assignments.go /^func main/,/^}/

* Указатели (Pointers)

- Променливите са парче памет, съдържащи стойност
- Указателят съдържа _адреса_ на променливата, т.е. мястото в паметта, където се съхранява
- В Go указателите са по-прости от тези в C - няма аритметика с указатели
- Позволяват предаването на обекти, без да се копират

.play code/pointers.go /^func main/,/^}/

- Дерефериране на нулев указател (със стойност `nil`) - паника
- Функциите могат да връщат указатели към локални променливи

* Функцията new

- `new` създава нова променлива от даден тип `T`, инициализира я с нулева стойност и връща адреса й, който е от тип `*T`

.play code/new.go /^func main/,/^}/

* Живот на променливите

- Променливите на ниво пакет съществуват по време на цялото изпълнение на програмата
- Локалните променливи (включително параметрите на функциите) се създават при всяко изпълнение на декларацията и живеят докато станат _недостижими_ (_unreachable_)
- Когато променлива стане недостижима, паметта, заделена за нея, може да бъде освободена/преизползвана
- Компилаторът преценява дали да задели памет за всяка променлива в _heap-a_ или в _stack-a_
- Променливите, които продължават да са достижими след изпълнението на функцията, се заделят на _heap-a_.

* Базови вградени типове

- int, int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64
- float32, float64, complex64, complex128
- bool
- string

int и uint са най-ефективния или естествен размер за конкретната платформа

- Константи могат да са само един от горните базови типове

  const pi = 3.14159

* Масиви (arrays)

- Подобни на масивите в C/C++
- Размерът им трябва да е ясен по време на компилация и не може да се променя

.play code/arrays.go /^func main/,/^}/

* Резени (slices)

- Могат да бъдат създавани по време на изпълнение с даден размер и капацитет
.play code/slices.go /^func main/,/^}/

- Отрязването на част от резен преизползва същото парче памет
.play code/slices2.go /^func main/,/^}/

* Речници (Maps)

- Съответствие от една стойност (ключ) към друга (стойност)

.play code/maps.go /^func main/,/^}/

- Проверка за съществуване на ключ

.play code/maps_in.go /^func main/,/^}/

* Речници (Maps) (2)

- Обхождане

.play code/maps_walk.go /^func main/,/^}/

- Референтен тип, има нулева стойност `nil`, опитите за опериране върху нея предизвикват `panic`

.play code/maps_nil.go /^func main/,/^}/

* Функции
	func plus(x, y int) int {
		return x + y
	}

- Просто разпределяне на аргумент
- Първокласни граждани
- Функции от по-висок ред
- Анонимни функции

* 1 1 2 3 ...

.play code/fib.go

* Defer

.play code/defer.go /BEGIN/,/END/

- Изпълняват се при излизане от обхвата на функцията
- Изпълняват се винаги
- Удобно за почистване / освобождаване на ресурси

* Exceptions
- Липсват
- Грешките са стойности и се връщат като резултат

	func foo() error {
		return fmt.Errorf("This is an error")
	}

- Имплементират `error` интерфейса

	type error interface {
		Error() string
	}

- Идиоматичният начин за справяне с грешки

	f, err := os.Open("filename.ext")
	if err != nil {
		...
	}


* Паника!
.image assets/Panic.jpg _ 100

- По подразбиране прекратява изпълнението на програмата

.play code/panic.go /START OMIT/,/END OMIT/

* Всичко ще се оправи

.play code/panic_recover.go /START OMIT/,/END OMIT/

- Подобно на обработка на `exception`, но не се насърчава за обработка на грешки
- recover има смисъл само в defer

* Структури

- Тип, агрегиращ нула или повече именовани стойности от произволен тип (_полета_, _fields_)
- Само полетата с имена, започващи с главна буква, са достъпни извън пакета, където е дефинирана структурата

.play code/structs.go /START OMIT/,/END OMIT/

* Методи върху структури

.play code/structs3.go /START OMIT/,/END OMIT/

- Дефинират се върху копие на структурата или върху указател
- Ако са дефинирани върху указател, структурата не се копира при извикването на метода

* Вграждане на структури (Struct embedding)

- Анонимни полета - с тип, но без име
- Полетата на вградената структура са достъпни директно

.play code/structs2.go /START OMIT/,/END OMIT/

* Вграждане на структури (Struct embedding) (2)

.image assets/mat.jpg _ 200

- Вграждането не е наследяване
- Следният код предизвиква компилационна грешка

.play code/structs4.go /START OMIT/,/END OMIT/

* Интерфейси
.image assets/duck.jpg 540 _

* Интерфейси

- Интерфейсните типове описват множество от методи, които конкретните типове трябва да притежават, за да се считат за инстанция на интерфейса
- Пример от стандартната библиотека `fmt`

  type Stringer interface {
        String() string
  }

- Използва се от `fmt.Printf` за интерполация в стринг с `%s` спецификатор

.play code/interfaces.go /START OMIT/,/END OMIT/

* Празен интерфейс и duck typing

  var value interface{}

- Във `value` можем да пазим всякакви стойности
- Проверка на тип

.play code/interfaces2.go /START OMIT/,/END OMIT/

* Communicating Sequential Processes (Hoare, 1978)

.image assets/csp.jpg _ 180

- Конкурентните програми се структурират като независими процеси
- Процесите обменят съобщения
- _Конкурентност_ - описанието на едновременни процеси програмата
- _Паралелизъм_ - едновременнето изпълнение на процесите
- _Конкурентните_ процеси не винаги се изпълняват паралелно

* Горутини

- Lightweight threads
- С малък стек, оразмеряващ се при необходимост
- Една Go програма може да има хиляди
- Изпълнение на функция в нова горутина

  go f(args)

- Go runtime-a автоматично разпределя горутините върху системни нишки
- Блокиращите горутини не заемат нишка

* Канали

- Горутините могат да си комуникират чрез канали

  c := make(chan int)

- Изпращане по канал
  c <- 42

- Четене от канал
  x := <- c

- Затваряне на канал

  close(c)

- Може да се използват за синхронизация

* Буферирани канали

- Небуфериран канал

  c := make(chan int)

- При писане блокира, ако никой не се опитва да чета
- При четене блокира, ако никой не се опитва да пише

- Буфериран канал

  c := make(chan int, 5)

- Писането блокира, само ако в канала има 5 непрочетени стойности
- Четенето блокира, само ако в канала няма нито една стойност

* Дядо коледа

- Изпраща на елфите желанията, прибира готовите подаръци и ги подарява

.play code/channels.go /^func santa/,/^}/

- Канали само за писане: `wishes` `chan<-` `string`
- Канали само за четене: `presents` `<-chan` `string`

* Джуджета

- Всяко джудже чете желанието от канала за желания, изработва подаръка и го изпраща по канала за подаръци

.play code/channels.go /^func elf/,/^}/

.image assets/elf.0.jpg _ 300

* Работилницата на Дядо Коледа

- Създаваме канали за желания и подаръци
- Пускаме една горутина за Дядо Коледа и по една горутина за всяко джудже

.play code/channels.go /^func main/,/^}/

- Буфериран `wishes` - не искаме Дядо Коледа да чака всяко желание да бъде готово, преди да пусне следващо
- Буфериран `presents` - не искаме всяко джудже да чака всички готови подаръци да са подарени, за да захване следващия подарък


* Стандартна библиотека

- time
- io
- log
- net и net/http
- os
- path
- sync
- unsafe

.caption Пълен списък на [[https://golang.org/pkg/][https://golang.org/pkg/]]

* Инструменти

	$ go
	Go is a tool for managing Go source code.
	...
	The commands are:

			build       compile packages and dependencies
			clean       remove object files
			doc         show documentation for package or symbol
			env         print Go environment information
			fix         run go tool fix on packages
			fmt         run gofmt on package sources
			generate    generate Go files by processing source
			get         download and install packages and dependencies
			install     compile and install packages and dependencies
			list        list packages
			run         compile and run Go program
			test        test packages
			tool        run specified go tool
			version     print Go version
			vet         run go tool vet on packages

	Use "go help [command]" for more information about a command.


* Управление на външни зависимости (пакети)

- Добавяне на зависимост (на практика копира сорса)

  go get github.com/google/uuid

- vendor support (GO15VENDOREXPERIMENT) от версия 1.5 позволява копирането на кода на външни зависимости в директорията на проекта. От 1.6 е включен по подразбиране

- Няма стандартен мениджър на зависимости и версиите им
- Godep, Glide, Govendor, godm, vexp, gv, govend, Vendetta, trash, gsv, gom, manul

* Управление на външни зависимости (пакети) (2)
.image assets/vendoring.png

* Мотики

.image assets/motika.jpg _ 600

* Мотики

Файловете в един и същи пакет споделят едно пространство от имена

.code code/motika1/file1.go

.code code/motika1/file2.go

- При настъпване:

  file2.go:3: x redeclared in this block previous declaration at file1.go:3

- Заобикаляне: избягване на твърде общи имена във всеки файл от даден пакет

* Мотики

- При използване на `:=` с няколко променливи, е нужно поне една от тях да не е декларирана в текущия лексикален обхват
- За вече декларираните променливи, операторът действа като присвояване
- Анонимните функции обаче създават нов лексикален обхват и се получава засенчване на вече декларираните променливи в обгръщащия обхват

.play code/pitfall_short.go /^func main/,/^}/

- При настъпване: неочаквано поведение
- Заобикаляне: присвояване на обграждащата променлива в отделен израз

* Мотики: нулев речник

- Четенето от нулев `map` връща нулева стойност за типа
- Опит за записване в нулев `map` предизвиква `panic`

.play code/motikanilslice.go /^func main/,/^}/

* Мотики: масиви

- За разлика от C, масивите се копират по стойност

.play code/motikaarraycopy.go

- Заобикаляне: използване на слайс; използване на указател към масив
- Това не важи за слайсовете (т.е. `[]int`), защото те са референтен тип

* Мотики: len

- `len` брои байтове, не Unicode символи

.play code/motikaunicode.go /^func main/,/^}/

- Заобикаляне: чрез `unicode/utf8` пакета

.play code/motikaunicodefix.go

* Мотики: range

- `range` връща копия на стойностите, по които се итерира
- Всички промени имат ефект само върху копията, не и оригинала

.play code/motikarange.go /^func main/,/^}/

- Заобикаляне: итериране с индекс; ползване на слайс от указатели


* Мотики (други)

- `log.Fatal*` предизвикват паника
- Главната програма не чака всички активни горутини да приключат
- Няма тип за множество (`set`), ползва се `map` с `bool` стойности
- "Pop" от слайс е грозно
  x, a = a[len(a)-1], a[:len(a)-1]
- Обръщането на слайс също не е красиво:
	for i := 0; i < len(numbers)/2; i++ {
		j := len(numbers) - i - 1
		numbers[i], numbers[j] = numbers[j], numbers[i]
	}

* Мотики (още други)
- Опитите за четене или писане в `nil` канал блокира вечно
- Четенето от затворен канал връща нулеви стойност, а писането предизвиква паника
- goroutine deadlocks and resource leaks
- slice resource leaks

* Misc

Неща, за които не остана време :(

- Споделена памет между горутини и синхронизация
- Дефиниране на типове `type`
- Reflection
- Тестване с `testing` пакета и `go` `test`
- Програмиране от ниско ниво с `unsafe`
- Тагове, сериализация и десериализация (`JSON`) на структури
- Runes, strings and bytes
- `context` пакета - удобен за пропагандиране на информация за request-a в мрежови приложения
- Variadic function arguments


* Среда за разработка

- Инсталация: [[https://golang.org/doc/install]]
- Workspace директория, съдържаща много repositories

	bin/ # Изпълними файлове (компилирани програми)
	pkg/ # Обектни файлове на пакетите
	src/ # Сорс код на проекти и зависимостите им
		hello/
		    hello.go
		golang.org/x/image/
				.git/
		github.com/google/uuid/
				.git/
- Създаване и указване на workspace

	$ mkdir $HOME/work
	$ export GOPATH=$HOME/work

- Дори под Windows официалният начин е през терминал и с environment variables. Повече на [[https://golang.org/doc/code.html]]

* Среда за разработка (2)

- Създаване на нов проект / repository
	$ mkdir -p $GOPATH/src/github.com/user

- Създаване на сорс файл `hello.go` в по-горе създадената директория

.play code/hello.go

- Билдване и пускане на програмата

	$ go build hello
	$ ./hello
	Здравей, свят!

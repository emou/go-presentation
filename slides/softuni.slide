Програмиране с езика Go
20 Декември 2016
Tags: golang, softuni

Емил Станчев, Ивелин Славов, Диан Тодоров
Uber Bulgaria
stanchev@uber.com
ivelin@uber.com
dido@uber.com

* Какво е Go?

.image assets/gopherbw.png _ 200

- Език с отворен код, който прави лесно създаването на опростен, надежден и ефикасен софтуер.
- Повърхностно подобен на C
- Автоматичен memory management
- Ефикасен модел на конкурентност
- Алтернатива на динамични скриптови езици с добавена сигурност на статичната типизация

* Малко за Gopher

- Автор: Renee French
- Също талисман на Plan 9
.image assets/glenda.png _ 200

* Още от Renee French

.image assets/renee.png _ 300

* Защо да пиша на Gо, а не на (постави език тук)

- Малък, идиоматичен и експресивен език
- Duck typing
- gofmt и други инструменти
- Конкурентност
- Static linking
- Бърза компилация
- Бързо изпълнение

* Compiling

.image assets/compiling.png _ 500

* История

.image ./assets/RobKenRobert.png _ 300

- 2007г: създаден като експеримент в Google през 2007г. от Robert Griesemer, Rob Pike, Ken Thompson.
- Не им харесва C++ и дългото време за компилация на големи приложения
- Ken Thompson е един от авторите на оригиналната Unix ОС и B - езика, предшественик на C.
- Rob Pike е работил в Bell Labs върху Plan 9 (Unix ОС)
- Март 2012г.: Go 1.0
- Август 2016г.: Go 1.7

* Какъв тип проекти са подходящи за Go?

- Простотата на езика го прави подходящ за големи проекти и дистрибутирани системи
- High-throughput, скалируеми network сървъри
- Command-line инструменти
- Инфраструктура (load balancers, cluster managers, docker)
- Автоматизация
- GUI - не особено
- Embedded софтуер, kernel development - не особено

* Go в Google

.image ./assets/datacenter.jpg _ 500

- Милиони редове код
- Хиляди програмисти
- Зилиони машини
- Известен брой datacenters
- Масивни C++ проекти със сложни зависимости, водещи до бавна компилация, изпълняваща се на сложна дистрибутирана билд система

* Go извън Google

Bitbucket
Booking.com
Dropbox
Facebook
GitHub
Google / YouTube
Heroku
Netflix
SoundCloud
SpaceX
Tumblr
Twitter
Uber
VMware
\...

* Open-source

- Docker - популярен инструмент за управление на Linux контейнери
- Doozer - конситентна, high-availability база данни
- InfluxDB - база данни за времеви редове (timeseries)
- Vault - инструмент за управление на криптирани тайни (напр. пароли)
- Packer - инструмент за създаване на образи на виртуални машини (VM images)
- Syncthing - клиент/сървър за синхронизация на файлове

* Hello World

.play code/hello.go

* Fizz buzz

.play code/fizzbuzz.go

* Пакети

  package main

- Пакетите са основна структурна единица на едно Go приложение
- Комбинация между библиотека, namespace и модул
- Всеки файл е част от точно един пакет. Един пакет може да включва много файлове
- По конвенция всяка директория съдържа един пакет
- Всяко изпълнимо приложение има точно един пакет `main` и една функция `main`
- Програмата приключва, когато `main` функцията приключи
- Няма циклични зависимости

* Използване на пакети

  import "main"

- Няколко пакета могат да бъдат импортирани с един `import`:

  import (
    "fmt"
    "encoding/json"
    "github.com/satori/go.uuid"
  )

- Достъпни са публичните (с главна буква) имена от пакета:

  fmt.Println("Hello!")

- Неизползването на импортирани пакети води до компилационна грешка

- При импортиране, може да бъде зададено алтернативно име:

  import "log"                          // Standard package
  import googlelog "google/base/go/log" // Google-specific package

* Променливи

- `var` създава нова променлива от даден тип, свързва я с име, и присвоява начална стойност

  var s string = "hello"
  var a, b, c = true, 3.14, "hello"
  var f, err = os.Open("filename")

- Кратка декларация на променливи (типът се извежда автоматично от компилатора)

  s := "hello"

- Обикновено се използва кратката декларация, освен ако не е нужно изрично указване на типа

* Присвояване на променливи

- Променя стойността на съществуваща променлива

.play code/assignments.go /^func main/,/^}/

* Указатели (Pointers)

- Променливите са парче памет, съдържащи стойност
- Указателят съдържа _адреса_ на променливата, т.е. мястото в паметта, където се съхранява
- В Go указателите са по-прости от тези в C - няма аритметика с указатели
- Позволяват предаването на обекти, без да се копират

.play code/pointers.go /^func main/,/^}/

- Дереференциране на нулев указател (със стойност `nil`) - паника
- Функциите могат да връщат указатели към локални променливи

* Функцията new

- `new` създава нова променлива от даден тип `T`, инициализира я с нулева стойност и връща адреса й, който е от тип `*T`

.play code/new.go /^func main/,/^}/

* Живот на променливите

- Променливите на ниво пакет съществуват по време на цялото изпълнение на програмата
- Локалните променливи (включително параметрите на функциите) се създават при всяко изпълнение на декларацията и живеят докато станат _недостижими_ (_unreachable_)
- Когато променлива стане недостижима, паметта, заделена за нея, може да бъде освободена/преизползвана
- Компилаторът преценява дали да задели памет за всяка променлива в _heap-a_ или в _stack-a_
- Променливите, които продължават да са достижими след изпълнението на функцията, се заделят на _heap-a_.

* Базови вградени типове

- int, int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64
- float32, float64, complex64, complex128
- bool
- string

int и uint са най-ефективния или естествен размер за конкретната платформа

- Константи могат да са само един от горните базови типове

  const pi = 3.14159

* Масиви (arrays)

- Подобни на масивите в C/C++
- Размерът им трябва да е ясен по време на компилация и не може да се променя

.play code/arrays.go /^func main/,/^}/

* Слайсове (slices)

- Могат да бъдат създавани по време на изпълнение с даден размер и капацитет
.play code/slices.go /^func main/,/^}/

- Отрязването на част от слайса преизползва същото парче памет
.play code/slices2.go /^func main/,/^}/

* Хеш-таблици (Maps)

- Съответствие от една стойност (ключ) към друга (стойност)

.play code/maps.go /^func main/,/^}/

- Проверка за съществуване на ключ

.play code/maps_in.go /^func main/,/^}/

* Хеш-таблици (Maps) (2)

- Обхождане

.play code/maps_walk.go /^func main/,/^}/

- Референтен тип, има нулева стойност `nil`, опитите за опериране върху нея предизвикват `panic`

.play code/maps_nil.go /^func main/,/^}/

* Функции
	func plus(x, y int) int {
		return x + y
	}

- Просто разпределяне на аргумент
- Първокласни граждани
- Функции от по-висок ред
- Анонимни функции

* 1 1 2 3 ...

.play code/fib.go

* Defer

.play code/defer.go

- Изпълняват се при излизане от обхвата на функцията
- Изпълняват се винаги
- Удобно за почистване / освобождаване на ресурси

* Exceptions
- Липсват
- Грешките са стойности и се връщат като резултат

	func foo() error {
		return fmt.Errorf("This is an error")
	}

- Имплементират `error` интерфейса

	type error interface {
		Error() string
	}

- Идиоматичният начин за справяне с грешки

	f, err := os.Open("filename.ext")
	if err != nil {
		...
	}


* Паника!
.image assets/Panic.jpg _ 100

- По подразбиране прекратява изпълнението на програмата

.play code/panic.go /START OMIT/,/END OMIT/

* Всичко ще се оправи

.play code/panic_recover.go /START OMIT/,/END OMIT/

- Подобно на обработка на `exception`, но не се насърчава за обработка на грешки
- recover има смисъл само в defer

* Структури

- Тип, агрегиращ нула или повече именовани стойности от произволен тип (_полета_, _fields_)
- Само полетата с имена, започващи с главна буква, са достъпни извън пакета, където е дефинирана структурата

.play code/structs.go /START OMIT/,/END OMIT/

* Методи върху структури

.play code/structs3.go /START OMIT/,/END OMIT/

- Дефинират се върху копие на структурата или върху указател
- Ако са дефинирани върху указател, структурата не се копира при извикването на метода

* Вграждане на структури (Struct embedding)

- Анонимни полета - с тип, но без име
- Полетата на вградената структура са достъпни директно

.play code/structs2.go /START OMIT/,/END OMIT/

* Вграждане на структури (Struct embedding) (2)

.image assets/mat.jpg _ 200

- Вграждането не е наследяване
- Следният код предизвиква компилационна грешка

.play code/structs4.go /START OMIT/,/END OMIT/

* Интерфейси

- Интерфейсните типове описват множество от методи, които конкретните типове трябва да притежават, за да се считат за инстанция на интерфейса
- Пример от стандартната библиотека `fmt`

  type Stringer interface {
        String() string
  }

- Използва се от `fmt.Printf` за интерполация в стринг с `%s` спецификатор

.play code/interfaces.go /START OMIT/,/END OMIT/

* Празен интерфейс и duck typing

  var value interface{}

- Във `value` можем да пазим всякакви стойности
- Проверка на тип

.play code/interfaces2.go /START OMIT/,/END OMIT/

* Communicating Sequential Processes (Hoare, 1978)

.image assets/csp.jpg _ 180

- Конкурентните програми се структурират като независими процеси
- Процесите обменят съобщения
- _Конкурентност_ - описанието на едновременни процеси програмата
- _Паралелизъм_ - едновременнето изпълнение на процесите
- _Конкурентните_ процеси не винаги се изпълняват паралелно

* Горутини

- Lightweight threads
- С малък стек, оразмеряващ се при необходимост
- Една Go програма може да има хиляди
- Изпълнение на функция в нова горутина

  go f(args)

- Go runtime-a автоматично разпределя горутините върху системни нишки
- Блокиращите горутини не заемат нишка

* Канали

- Горутините могат да си комуникират чрез канали

  intChannel := make(chan int)

- Изпращане по канал
  c <- 42

- Четене от канал
  x := <- c

- Затваряне на канал

  close(c)

- Може да се използват за синхронизация

* Буферирани канали

- Небуфериран канал

  intChannel := make(chan int)

- При писане блокира, ако никой не се опитва да чета
- При четене блокира, ако никой не се опитва да пише

- Буфериран канал

  intChannel := make(chan int, 5)

- Писането блокира, само ако в канала има 5 непрочетени стойности
- Четенето блокира, само ако в канала няма нито една стойност

* Дядо коледа

- Изпраща на елфите заявки за подаръци, прибира подаръците, когато са готови, и ги подарява

.play code/channels.go /^func santa/,/^}/

- Канал само за писане: `wishes` `chan<-` `string`
- Канал само за четене: `presents` `<-chan` `string`

* Джуджета

- Всяко джудже чете желанието от канала за желания, изработва подаръка и го изпраща по канала за подаръци

.play code/channels.go /^func elf/,/^}/

.image assets/elf.0.jpg _ 300

* Работилницата на Дядо Коледа

- Създаваме канали за желания и подаръци
- Пускаме една горутина за Дядо Коледа и по една горутина за всяко джудже

.play code/channels.go /^func main/,/^}/

- Буфериран `wishes` - не искаме Дядо Коледа да чака всяко желание да бъде готово, преди да пусне следващо
- Буфериран `presents` - не искаме всяко джудже да чака всички готови подаръци да са подарени, за да захване следващия подарък


* Стандартна библиотека

- time
- io
- log
- net и net/http
- os
- path
- sync

.caption Пълен списък на [[https://golang.org/pkg/][https://golang.org/pkg/]]

* Misc

Неща, за които не остана време :(

- Споделена памет между горутини и синхронизация
- Дефиниране на типове `type`
- Reflection
- Тестване с `testing` пакета и `go` `test`
- Програмиране от ниско ниво с `unsafe`
- Тагове, сериализация и десериализация (`JSON`) на структури
- Runes, strings and bytes
- `context` пакета - удобен за пропагандиране на информация за request-a в мрежови приложения
- Variadic function arguments

* Инструменти

	$ go
	Go is a tool for managing Go source code.

	Usage:

			go command [arguments]

	The commands are:

			build       compile packages and dependencies
			clean       remove object files
			doc         show documentation for package or symbol
			env         print Go environment information
			fix         run go tool fix on packages
			fmt         run gofmt on package sources
			generate    generate Go files by processing source
			get         download and install packages and dependencies
			install     compile and install packages and dependencies
			list        list packages
			run         compile and run Go program
			test        test packages
			tool        run specified go tool
			version     print Go version
			vet         run go tool vet on packages

	Use "go help [command]" for more information about a command.


* Управление на външни зависимости (пакети)

- Добавяне на зависимост (на практика копира сорса)

  go get github.com/google/uuid

- vendor support (GO15VENDOREXPERIMENT) от версия 1.5 позволява копирането на кода на външни зависимости в директорията на проекта

- Няма стандартен мениджър на зависимости и версиите им
- Godep, Glide, Govendor, godm, vexp, gv, govend, Vendetta, trash, gsv, gom, manul

* Мотики

.image assets/motika.jpg _ 600

* Мотики

Файловете в един и същи пакет споделят едно пространство от имена

.code code/motika1/file1.go

.code code/motika1/file2.go

- При настъпване:

  file2.go:3: x redeclared in this block previous declaration at file1.go:3

- Заобикаляне: избягване на твърде общи имена във всеки файл от даден пакет

* Мотики

- При използване на `:=` с няколко променливи, е нужно поне една от тях да не е декларирана в текущия лексикален скоуп
- За вече декларираните променливи, операторът действа като присвояване
- Анонимните функции обаче създават нов лексикален скоуп и се получава засенчване на вече декларираните променливи в обгръщаия скоуп

.play code/pitfall_short.go /^func main/,/^}/

- При настъпване: неочаквано поведение
- Заобикаляне: присвояване на обграждащата променлива в отделен израз

* Мотики: нулев `map`

- Четенето от нулев `map` връща нулева стойност за типа
- Опит за записване в нулев `map` предизвиква `panic`

.play code/motikanilslice.go /^func main/,/^}/

* Мотики: масиви

- За разлика от C, масивите се копират по стойност

.play code/motikaarraycopy.go

- Заобикаляне: използване на слайс; използване на указател към масив
- Това не важи за слайсовете (т.е. `[]int`), защото те са референтен тип

* Мотики: len

- `len` брои байтове, не Unicode символи

.play code/motikaunicode.go /^func main/,/^}/

- Заобикаляне: чрез `unicode/utf8` пакета

.play code/motikaunicodefix.go

* Мотики: range

- `range` връща копия на стойностите, по които се итерира
- Всички промени имат ефект само върху копията, не и оригинала

.play code/motikarange.go /^func main/,/^}/

- Заобикаляне: итериране с индекс; ползване на слайс от указатели


* Мотики (други)

- `log.Fatal*` предизвикват паника
- Главната програма не чака всички активни горутини да приключат
- Няма тип за множество (`set`), ползва се `map` с `bool` стойности
- Опитите за четене или писане в `nil` канал блокира вечно
- Четенето от затворен канал връща нулеви стойност, а писането предизвиква паника
- "Pop" от слайс е грозно
  x, a = a[len(a)-1], a[:len(a)-1]
- Обръщането на слайс също не е красиво:
	for i := 0; i < len(numbers)/2; i++ {
		j := len(numbers) - i - 1
		numbers[i], numbers[j] = numbers[j], numbers[i]
	}
- goroutine deadlocks and resource leaks
- slice resource leaks
